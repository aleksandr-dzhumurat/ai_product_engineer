
Python Performance: list internals

### Почему append O(1), а insert(0) O(n)?

**List = динамический массив** (не linked list!)
```
Внутреннее устройство:
lst = [1, 2, 3]
Память: [1][2][3][_][_][_]  ← Есть запас (capacity > size)

append(4):  O(1)
[1][2][3][4][_][_]  ← Просто записываем в следующую ячейку

insert(0, 0): O(n)
Нужно сдвинуть ВСЕ элементы вправо:
[1][2][3] → [_][1][2][3]
            Shift!
```

**Амортизированная O(1) для append:**
```
Capacity заполнен → нужно расширение

Старый массив: [1,2,3,4] capacity=4
Новый массив: [1,2,3,4,_,_,_,_,_] capacity=9

Копирование: O(n)
Но происходит редко!

В среднем: O(1) амортизированная